# 명령어
명령어에 대해 알아봅시다. 우리가 작성한 코드들은 어떻게 컴퓨터가 이해하는 명령어로 바뀔까요?

<br/>

## 고급 언어와 저급언어

프로그래밍 언어는 쉽게 고급언어와 저급언어로 나눌 수 있습니다.

고급언어는 우리가 배우는 c++, python, java, javascript같이 프로그램을 만들 때 사용하는 프로그래밍 언어이죠. 이런 고급언어는 컴퓨터가 바로 해석할 수 없습니다. 

고급언어를 `컴파일러`가 컴파일을 통해 저급언어로 바꾸어 주고, 이 어셈블리어를 `어셈블러`라는 특수한 유틸리티 프로그램에 의해 기계어로 최종적으로 변경됩니다. `0100101`이렇게 말이죠. 이 기계어는 컴퓨터가 직접 이해하고 실행할 수 있게됩니다. 

컴파일러가 어떻게 고급언어를 어셈블리어로 바꾸는지, 어셈블러가 어떻게 어셈블리어를 기계어로 바꾸는지는 컴파일러 수업이나 대학원 과정에서 배우도록 합시다 🙂

<br/>


## 고급언어를 어셈블리어로 변경하기

```cpp
int a = 2;
int b = 3;
int c = a + b;
```

예를 들어 우리가 c++로 작성한 이런 코드는

<br/>


```cpp
addi x3, x4, x5
```
<br/>

만약 b는 x4 레지스터에, c는 x5 레지스터에 저장되어 있다면 어셈블리어로 이렇게 작성할 수 있습니다. 어셈블리어 문법 몇개를 더 알아볼까요?

<br/>

```nasm
addi x23, x22, 4 
```

`addi`는 add와 다르게 상수 더하기가 가능합니다. 해석하면 x22 레지스터에 저장된 값에 4를 더해서 x23에 저장하라 겠군요

<br/>

```nasm
sub x19, x5, x6
```

`sub`는 보자마자 뺄셈이라는 것이 느껴집니다. 해석하면 x5레지스터에 저장된 값에서 x6레지스터에 저장된 값을 빼서 x19레지스터에 넣어라 겠군요

<br/>

```nasm
lw x9, 32(x22)
```

`lw`는 "Load Word"를 의미합니다. **`lw`** 명령어는 주어진 메모리에서 데이터를 읽어 레지스터에 저장하는 역할을 합니다. 이 경우 x22 레지스터에 저장된 값에서 32를 더한 메모리 주소에서 데이터를 읽어 x9레지스터에 저장하라는 의미입니다.

<br/>

```nasm
sw x9, 32(x22)
```

`sw` 는 “Store Word”를 의미합니다. `sw`명령어는 `lw`명령어와 반대로 레지스터에 저장된 데이터를 메모리의 주어진 위치에 저장하는 역할을 합니다. 이 경우 x9레지스터에 저장된 값을 x22레지스터에 저장된 값에 32를 더해서 얻은 메모리의 주소를 이용해 그 메모리의 공간에 저장하라는 의미입니다. 

이 외에도 여러가지가 있지만 여기까지만 알아보도록 합시다.
뭐 이렇게 까지 바꾸는건 어느정도 이해가 됩니다. 하지만 컴퓨터는 0과 1만 이해할 수 있는데 이걸 어떻게 해석한다는 걸까요? 따라서 최종적으로 이 어셈블리어 코드를 컴퓨터가 이해할 수 있도록 기계어로 변경해 주어야합니다.

<br/>

## 어셈블리어를 기계어로 변경하기

이제 마지막으로 컴퓨터가 알아볼 수 있게 `10101..` 이런 기계어로 변경해주어야 합니다. 컴퓨터는 기계어 명령어 형식을 정해두어서 어셈블리어를 해석할 수 있게 됩니다. 컴퓨터 프로세서 설계 방식에는 여러가지가 있습니다. 이 설계 방식에 따라 기계어를 만드는 방식이 달라집니다. 저희는 그 중 한가지인 `RISC방식`에 대해 알아보겠습니다. RISC 아키텍처에서 명령어는 일반적으로 32비트로 구성됩니다. 32비트 명령어는 고정된 길이를 가지며, 명령어의 필드가 명확하게 정의되어 있어 해독과 실행이 간단하고 빠릅니다.

<br/>

### R-format instruction(덧셈, 뺄셈)

![Untitled 1](https://github.com/gkqkehs7/Computer-Structure/assets/77993709/674cc653-d7ba-4efd-bfbf-b3778585a565)

이건 RISC의 덧셈 format형식입니다. 덧셈과 뺄셈을 할때는 이 명령어 형식을 따릅니다.

<br/>

```bash
add x9, x20, x21
```

만약 레지스터 x20에 저장된 값과 x21에 저장된 값을 더해서 x9 레지스터에 저장하는 어셈블리어가 있다면 위의 형식에 각각 값을 넣으면 됩니다. 여기선 rs1에는 x20, rs2에는 x21, rd에는 x9를 넣으면 되겠죠. 덧셈에 해당하는 funct7과 funct3, opcode는 이미 정해져 있습니다. 그렇다면 최종적으로 위 어셈블리어는

0000000 10101 10100 000 01001 0110011로 변경 될 것입니다. cpu는 최종적으로 이 명령어를 해석하는 것입니다.

<br/>

### I-format instruction(상수의 덧셈, 뺄셈, lw)

![Untitled 2](https://github.com/gkqkehs7/Computer-Structure/assets/77993709/fb1c7ea3-4701-469f-90b7-52ee1ddded2a)

```bash
 addi x2, x1, 8
```

상수의 덧셈, 뺄셈, lw에는 위의 형식을 사용합니다.

같은 맥락으로 위 명령어는 000000001000 00001 000 00010 0110011이 되겠네요

<br/>

### S-format instruction(sw)**

![Untitled](https://github.com/gkqkehs7/Computer-Structure/assets/77993709/95eacd5d-35eb-4adf-aa62-a11d79b4a0a8)

```bash
sw x9, 120(x10)
```

데이터를 저장하는 sw명령어는 위 형식을 사용합니다.

0100 0000 0101 0011 1000 0011 0011001이 될 것입니다.

<br/>

## RISC vs CISC

그럼 아키텍쳐에는 RISC만 존재할까요? 그건 아닙니다. RISC와 비교되는 대표적인 아키텍처로 CISC가 존재합니다. 둘의 장단점을 비교하며 두가지를 더 자세하게 살펴봅시다.

### CISC

CISC는 복잡한 명령어 집합을 활용합니다. 이는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용합니다.

이는 적은 수의 명령어 만으로 프로그램을 동작시킬 수 있어, 메모리 공간을 절약할 수 있습니다. 

예로 인텔의 x86-64가 CISC를 사용하는데 ARM(Architecture for RISC Machines)명령어 여러 개로 수행할 수 있는 일을 x86-64명령어 몇 개 만으로 수행할 수 있음을 의미합니다.

하지만 CISC는 명령어 수행시간이 길고 길이가 가지각색이기 때문에 파이프라인이 효율적으로 명령어를 처리 할 수 없고, 이는 cpu성장에 한계가 있다는 것을 의미합니다.

<br/>

### RISC

따라서 등장한 것이 우리가 위에서 본 RISC입니다. RISC는 명령어의 종류가 CISC에 비해 적고, 짧고 

규칙화된 명령어 위주로 사용됩니다. 이는 나중에 배울 파이프라이닝에 최적화 된 것이라고 알 수 있습니다.

RISC는 메모리 접근을 최소화 하는 대신 레지스터를 적극적으로 활용하기 때문에,  CISC보다 레지스터를 이용하는 연산이 많고 레지스터 개수도 더 많습니다. 그리고 **고정길이 명령어**를 사용하여 사용 가능한 명령어가 적기 떄문에 CISC보다  더 많은 명령을 해야 프로그램을 작동시킬 수 있습니다.

위에서 살펴본 RISC는 스마트폰, 태블릿, 스마트워치 등 다양한 이동식 장치 ARM 아키텍처에서 사용됩니다. 

특히, 임베디드 시스템 분야에서는 RISC 아키텍처가 전력 효율성이 높고 비교적 간단한 명령어 집합을 가지고 있어서 많은 인기를 끌었습니다. 이후에는 PC 분야에서도 RISC 아키텍처를 사용하는 제품이 출시되었습니다.